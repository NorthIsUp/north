# generated by datamodel-codegen:
#   filename:  https://json.schemastore.org/partial-pytest.json
#   timestamp: 2025-10-07T20:59:20+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Extra, Field, conint


class ConsoleOutputStyle(Enum):
    classic = "classic"
    progress = "progress"
    progress_even_when_capture_no = "progress-even-when-capture-no"
    count = "count"


class EmptyParameterSetMark(Enum):
    skip = "skip"
    xfail = "xfail"
    fail_at_collect = "fail_at_collect"


class JunitDurationReport(Enum):
    total = "total"
    call = "call"


class JunitFamily(Enum):
    xunit1 = "xunit1"
    xunit2 = "xunit2"


class JunitLogging(Enum):
    no = "no"
    log = "log"
    system_out = "system-out"
    system_err = "system-err"
    out_err = "out-err"
    all = "all"


class LogAutoIndent(Enum):
    On = "On"
    Off = "Off"


class TmpPathRetentionPolicy(Enum):
    all = "all"
    failed = "failed"
    none = "none"


class VerbosityAssertions(Enum):
    auto = "auto"


class VerbosityTestCases(Enum):
    auto = "auto"


class AsyncioScope(Enum):
    function = "function"
    class_ = "class"
    module = "module"
    package = "package"
    session = "session"


class LogLevel1(Enum):
    CRITICAL = "CRITICAL"
    ERROR = "ERROR"
    WARNING = "WARNING"
    INFO = "INFO"
    DEBUG = "DEBUG"
    NOTSET = "NOTSET"


class LogLevel2(Enum):
    FATAL = "FATAL"
    WARN = "WARN"


class LogLevel(BaseModel):
    __root__: Union[conint(ge=0), LogLevel1, LogLevel2] = Field(..., description="A minimum log level. Can be level name or integer value.")


class IniOptions(BaseModel):
    class Config:
        extra = Extra.allow

    addopts: Optional[Union[List[str], str]] = Field(None, description="Extra command line options to be added by default.")
    cache_dir: Optional[str] = Field(
        ".pytest_cache",
        description="Sets directory for cache plugin. Can include environment variables.",
    )
    consider_namespace_packages: Optional[bool] = Field(
        False,
        description="Controls whether pytest attempts to identify namespace packages.",
    )
    console_output_style: Optional[ConsoleOutputStyle] = Field("progress", description="Sets console output style during test execution.")
    doctest_encoding: Optional[str] = Field(None, description="Sets default encoding for doctest files.")
    doctest_optionflags: Optional[Union[List[str], str]] = Field(
        None, description="Specifies doctest flag names from the `doctest` module."
    )
    empty_parameter_set_mark: Optional[EmptyParameterSetMark] = Field(
        "skip",
        description="Defines behavior for empty parameter sets in parameterization.",
    )
    faulthandler_timeout: Optional[int] = Field(
        None,
        description="Sets timeout in seconds for dumping the traceback of all threads if a test takes too long.",
    )
    filterwarnings: Optional[Union[List[str], str]] = Field(
        None,
        description="Sets action to take for matching warnings. Each item is a warning specification string.",
    )
    junit_duration_report: Optional[JunitDurationReport] = Field(
        "total", description="Sets how to record test durations in JUnit XML report."
    )
    junit_family: Optional[JunitFamily] = Field("xunit2", description="Sets format of generated JUnit XML files.")
    junit_logging: Optional[JunitLogging] = Field(
        "no",
        description="Controls whether captured output is written to JUnit XML file.",
    )
    junit_log_passing_tests: Optional[bool] = Field(
        True,
        description="If `junit_logging` is not 'no', controls whether to include output of passing tests.",
    )
    junit_suite_name: Optional[str] = Field(None, description="Sets name of root test suite in JUnit XML report.")
    log_auto_indent: Optional[Union[bool, conint(ge=0), LogAutoIndent]] = Field(
        None,
        description="Allows selective auto-indentation of multiline log messages. Can be true, false, positive integer, 'On', or 'Off'.",
    )
    log_cli: Optional[bool] = Field(False, description="Enables log display during test run (live logging).")
    log_cli_date_format: Optional[str] = Field(
        None,
        description="Sets date format for live logging using `time.strftime()` format.",
    )
    log_cli_format: Optional[str] = Field(None, description="Sets message format for live logging using `logging` format.")
    log_cli_level: Optional[LogLevel] = Field(
        None,
        description="Sets minimum log level for live logging. Can be level name or integer value.",
    )
    log_date_format: Optional[str] = Field(
        None,
        description="Sets date format for captured logging using `time.strftime()` format.",
    )
    log_file: Optional[str] = Field(None, description="Sets file path to write log messages to.")
    log_file_date_format: Optional[str] = Field(
        None,
        description="Sets date format for log file using `time.strftime()` format.",
    )
    log_file_format: Optional[str] = Field(None, description="Sets message format for log file using `logging` format.")
    log_file_level: Optional[LogLevel] = Field(
        None,
        description="Sets minimum log level for log file. Can be level name or integer value.",
    )
    log_format: Optional[str] = Field(
        None,
        description="Sets message format for captured logging using `logging` format.",
    )
    log_level: Optional[LogLevel] = Field(
        None,
        description="Sets minimum log level for captured logging. Can be level name or integer value.",
    )
    markers: Optional[Union[List[str], str]] = Field(None, description="Allows registering additional markers for test functions.")
    minversion: Optional[str] = Field(None, description="Specifies minimum required pytest version.")
    norecursedirs: Optional[Union[List[str], str]] = Field(
        None,
        description="Sets base name patterns for directories to be skipped during test discovery. Uses fnmatch-style matching. Replaces default patterns.",
    )
    python_classes: Optional[Union[List[str], str]] = Field(
        None,
        description="Specifies name prefixes or glob patterns for identifying test classes.",
    )
    python_files: Optional[Union[List[str], str]] = Field(
        ["test_*.py", "*_test.py"],
        description="Specifies glob patterns for identifying Python test module files.",
    )
    python_functions: Optional[Union[List[str], str]] = Field(
        ["test_*"],
        description="Specifies name prefixes or glob patterns for identifying test functions and methods.",
    )
    pythonpath: Optional[Union[List[str], str]] = Field(
        None,
        description="Sets list of directories to be added to the Python search path. Paths are relative to root directory.",
    )
    required_plugins: Optional[Union[List[str], str]] = Field(
        None,
        description="Space-separated list of plugins required to run pytest. Can include version specifiers.",
    )
    testpaths: Optional[Union[List[str], str]] = Field(
        None,
        description="Sets directories to search for tests when no specific paths are given on the command line. Paths are relative to root directory. Shell-style wildcards can be used.",
    )
    tmp_path_retention_count: Optional[int] = Field(3, description="Number of sessions to retain `tmp_path` directories for.")
    tmp_path_retention_policy: Optional[TmpPathRetentionPolicy] = Field(
        "all",
        description="Controls which `tmp_path` directories to retain based on test outcome.",
    )
    usefixtures: Optional[Union[List[str], str]] = Field(None, description="List of fixtures that will be applied to all test functions.")
    verbosity_assertions: Optional[Union[conint(ge=0), VerbosityAssertions]] = Field(
        None,
        description="Sets verbosity specific to assertion-related output. Can be integer or 'auto'.",
    )
    verbosity_test_cases: Optional[Union[conint(ge=0), VerbosityTestCases]] = Field(
        None,
        description="Sets verbosity specific to test case execution output. Can be integer or 'auto'.",
    )
    xfail_strict: Optional[bool] = Field(
        False,
        description="If true, test suite will fail if a test marked with `@pytest.mark.xfail` unexpectedly passes.",
    )


class IniOptionsAsyncio(BaseModel):
    class Config:
        extra = Extra.allow

    asyncio_default_fixture_loop_scope: Optional[AsyncioScope] = Field(
        None,
        description="Default event loop scope of asynchronous fixtures. When this configuration option is unset, it defaults to the fixture scope. In future versions of pytest-asyncio, the value will default to function when unset",
    )
    asyncio_default_test_loop_scope: Optional[AsyncioScope] = Field(
        "function",
        description="Default event loop scope of asynchronous tests. When this configuration option is unset, it default to function scope",
    )
    asyncio_mode: Optional[str] = Field("strict", description="Sets the asyncio mode for pytest-asyncio.")


class IniOptionsModel(IniOptions, IniOptionsAsyncio):
    pass


class Model(BaseModel):
    class Config:
        extra = Extra.forbid

    ini_options: Optional[IniOptionsModel] = Field(
        None,
        description="The `ini_options` table is used as a bridge between the existing `pytest.ini` configuration system and future configuration formats. `pytest.ini` takes precedence over `[tool.pytest.ini_options]` in `pyproject.toml`.",
        title="Bridge Configuration Options for `pytest.ini` File",
    )
