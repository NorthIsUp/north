# generated by datamodel-codegen:
#   filename:  https://json.schemastore.org/poetry.json
#   timestamp: 2025-10-07T20:59:14+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Extra, Field, constr


class Plugins(BaseModel):
    class Config:
        extra = Extra.forbid

    ignore: Optional[str] = Field(None, description="Flag that prevents the plugin from loading the dotenv file.")
    location: Optional[str] = Field(
        None,
        description="Path to the dotenv file. It can be both absolute or relative.",
    )


class Name(BaseModel):
    pass


class PoetryName(BaseModel):
    __root__: str = Field(..., description="Package name.")


class PoetryVersion(BaseModel):
    __root__: str = Field(
        ...,
        description="Version of the package. It should follow semantic versioning, but it is not enforced.",
    )


class PoetryDescription(BaseModel):
    __root__: constr(regex=r"^[^\n]*$") = Field(..., description="Short package description.")


class PoetryAuthorPattern(BaseModel):
    __root__: constr(regex=r'^(?:[- .,\w\d\'â€™"():&]+)(?: <(?:.+?)>)?') = Field(
        ...,
        description="Pattern that matches `Name <email>` like 'King Arthur' or 'Miss Islington &lt;miss-islington@python.org&gt;'.",
    )


class PoetryAuthors(BaseModel):
    __root__: List[PoetryAuthorPattern] = Field(
        ...,
        description="List of authors that contributed to the package. This is typically the main maintainers, not the full list.",
    )


class PoetryMaintainers(BaseModel):
    __root__: List[PoetryAuthorPattern] = Field(
        ...,
        description="List of maintainers, other than the original author(s), that upkeep the package.",
    )


class PoetryIncludePath(BaseModel):
    __root__: str = Field(..., description="Path to file or directory to include.")


class PoetryPackageFormat(Enum):
    sdist = "sdist"
    wheel = "wheel"


class PoetryPackageFormats(BaseModel):
    __root__: Union[PoetryPackageFormat, List[PoetryPackageFormat]] = Field(
        ..., description="The format(s) for which the package must be included."
    )


class PoetryPep440Version(BaseModel):
    __root__: str = Field(
        ...,
        description="A version constraint. Validates against the PEP 440's version pattern.",
    )


class PoetryDependency(BaseModel):
    __root__: PoetryPep440Version


class PoetryLongDependency(BaseModel):
    class Config:
        extra = Extra.forbid

    version: PoetryPep440Version
    python: Optional[str] = Field(
        None,
        description="The python versions for which the dependency should be installed.",
    )
    platform: Optional[str] = Field(
        None,
        description="The platform(s) for which the dependency should be installed.",
    )
    markers: Optional[str] = Field(
        None,
        description="The PEP 508 compliant environment markers for which the dependency should be installed.",
    )
    allow_prereleases: Optional[bool] = Field(
        None,
        alias="allow-prereleases",
        description="Whether the dependency allows prereleases or not.",
    )
    allows_prereleases: Optional[bool] = Field(
        None,
        alias="allows-prereleases",
        description="Whether the dependency allows prereleases or not.",
    )
    optional: Optional[bool] = Field(None, description="Whether the dependency is optional or not.")
    extras: Optional[List[str]] = Field(None, description="The required extras for this dependency.")
    source: Optional[str] = Field(None, description="The exclusive source used to search for this dependency.")


class PoetryGitDependency(BaseModel):
    class Config:
        extra = Extra.forbid

    git: Union[
        AnyUrl,
        constr(regex=r"^([A-Za-z0-9\-]+@|https://|http://)[A-Za-z][A-Za-z0-9+.-]*(:|/)[A-Za-z0-9\-\.]+(/[A-Za-z0-9\-_\.]+)+\.git$"),
    ] = Field(..., description="The url of the git repository.")
    branch: Optional[str] = Field(None, description="The branch to checkout.")
    tag: Optional[str] = Field(None, description="The tag to checkout.")
    rev: Optional[str] = Field(None, description="The revision to checkout.")
    subdirectory: Optional[str] = Field(
        None,
        description="The relative path to the directory where the package is located.",
    )
    python: Optional[str] = Field(
        None,
        description="The python versions for which the dependency should be installed.",
    )
    platform: Optional[str] = Field(
        None,
        description="The platform(s) for which the dependency should be installed.",
    )
    markers: Optional[str] = Field(
        None,
        description="The PEP 508 compliant environment markers for which the dependency should be installed.",
    )
    allow_prereleases: Optional[bool] = Field(
        None,
        alias="allow-prereleases",
        description="Whether the dependency allows prereleases or not.",
    )
    allows_prereleases: Optional[bool] = Field(
        None,
        alias="allows-prereleases",
        description="Whether the dependency allows prereleases or not.",
    )
    optional: Optional[bool] = Field(None, description="Whether the dependency is optional or not.")
    extras: Optional[List[str]] = Field(None, description="The required extras for this dependency.")
    develop: Optional[bool] = Field(None, description="Whether to install the dependency in development mode.")


class PoetryFileDependency(BaseModel):
    class Config:
        extra = Extra.forbid

    file: str = Field(..., description="The path to the file.")
    python: Optional[str] = Field(
        None,
        description="The python versions for which the dependency should be installed.",
    )
    platform: Optional[str] = Field(
        None,
        description="The platform(s) for which the dependency should be installed.",
    )
    markers: Optional[str] = Field(
        None,
        description="The PEP 508 compliant environment markers for which the dependency should be installed.",
    )
    optional: Optional[bool] = Field(None, description="Whether the dependency is optional or not.")
    extras: Optional[List[str]] = Field(None, description="The required extras for this dependency.")


class PoetryPathDependency(BaseModel):
    class Config:
        extra = Extra.forbid

    path: str = Field(..., description="The path to the dependency.")
    python: Optional[str] = Field(
        None,
        description="The python versions for which the dependency should be installed.",
    )
    platform: Optional[str] = Field(
        None,
        description="The platform(s) for which the dependency should be installed.",
    )
    markers: Optional[str] = Field(
        None,
        description="The PEP 508 compliant environment markers for which the dependency should be installed.",
    )
    optional: Optional[bool] = Field(None, description="Whether the dependency is optional or not.")
    extras: Optional[List[str]] = Field(None, description="The required extras for this dependency.")
    develop: Optional[bool] = Field(None, description="Whether to install the dependency in development mode.")


class PoetryUrlDependency(BaseModel):
    class Config:
        extra = Extra.forbid

    url: str = Field(..., description="The url to the file.")
    python: Optional[str] = Field(
        None,
        description="The python versions for which the dependency should be installed.",
    )
    platform: Optional[str] = Field(
        None,
        description="The platform(s) for which the dependency should be installed.",
    )
    markers: Optional[str] = Field(
        None,
        description="The PEP 508 compliant environment markers for which the dependency should be installed.",
    )
    optional: Optional[bool] = Field(None, description="Whether the dependency is optional or not.")
    extras: Optional[List[str]] = Field(None, description="The required extras for this dependency.")


class PoetryMultipleConstraintsDependency(BaseModel):
    __root__: List[
        Union[
            PoetryDependency,
            PoetryLongDependency,
            PoetryGitDependency,
            PoetryFileDependency,
            PoetryPathDependency,
            PoetryUrlDependency,
        ]
    ] = Field(..., min_items=1)


class PoetryScriptLegacy(BaseModel):
    __root__: str = Field(..., description="A simple script pointing to a callable object.")


class Type(Enum):
    file = "file"
    console = "console"


class PoetryExtraScripts(BaseModel):
    class Config:
        extra = Extra.forbid

    reference: str = Field(
        ...,
        description="If type is file this is the relative path of the script file, if console it is the module name.",
    )
    type: Type = Field(..., description="Value can be either file or console.")
    extras: Optional[List[str]] = Field(
        None,
        description="The required extras for this script. Only applicable if type is console.",
    )


class PoetryExtraScriptLegacy(BaseModel):
    class Config:
        extra = Extra.forbid

    callable: Optional[PoetryScriptLegacy] = Field(
        None,
        description="The entry point of the script. Deprecated in favour of reference.",
    )
    extras: Optional[List[str]] = Field(None, description="The required extras for this script.")


class PoetryBuildScript(BaseModel):
    __root__: str = Field(..., description="The python script file used to build extensions.")


class PoetryBuildConfig(BaseModel):
    class Config:
        extra = Extra.forbid

    generate_setup_file: Optional[bool] = Field(
        True,
        alias="generate-setup-file",
        description="Generate and include a setup.py file in sdist.",
    )
    script: Optional[PoetryBuildScript] = None


class PoetryBuildSection(BaseModel):
    __root__: Union[PoetryBuildScript, PoetryBuildConfig]


class PoetryPriority(Enum):
    default = "default"
    primary = "primary"
    secondary = "secondary"
    supplemental = "supplemental"
    explicit = "explicit"


class Package(BaseModel):
    class Config:
        extra = Extra.forbid

    include: PoetryIncludePath
    from_: Optional[str] = Field(
        None,
        alias="from",
        description="Where the source directory of the package resides.",
    )
    format: Optional[PoetryPackageFormats] = None
    to: Optional[str] = Field(
        None,
        description="Where the package should be installed in the final distribution.",
    )


class Include(BaseModel):
    class Config:
        extra = Extra.forbid

    path: PoetryIncludePath
    format: Optional[PoetryPackageFormats] = None


class Dependencies(BaseModel):
    python: Optional[PoetryDependency] = Field(None, description="The Python versions the package is compatible with.")


class Source(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str = Field("pypi", const=True, description="The name of the source.")
    priority: Optional[PoetryPriority] = Field(None, description="The priority of the source.")


class Source1(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Name = Field(..., description="The name of the source.")
    url: AnyUrl = Field(..., description="The url of the source.")
    priority: Optional[PoetryPriority] = Field(None, description="The priority of the source.")


class PoetryDependencyAny(BaseModel):
    __root__: Union[
        PoetryDependency,
        PoetryLongDependency,
        PoetryGitDependency,
        PoetryFileDependency,
        PoetryPathDependency,
        PoetryUrlDependency,
        PoetryMultipleConstraintsDependency,
    ]


class PoetryScriptTable(BaseModel):
    __root__: Union[PoetryExtraScriptLegacy, PoetryExtraScripts]


class Group(BaseModel):
    class Config:
        extra = Extra.forbid

    optional: Optional[bool] = Field(None, description="Whether the dependency group is optional or not")
    dependencies: Dict[constr(regex=r"^[a-zA-Z-_.0-9]+$"), PoetryDependencyAny] = Field(
        ..., description="The dependencies of this dependency group"
    )


class PartialPoetry(BaseModel):
    class Config:
        extra = Extra.allow

    package_mode: Optional[bool] = Field(
        True,
        alias="package-mode",
        description="Whether Poetry operates in package mode or not.",
    )
    name: Optional[PoetryName] = None
    version: Optional[PoetryVersion] = None
    description: Optional[PoetryDescription] = None
    keywords: Optional[List[str]] = None
    homepage: Optional[AnyUrl] = Field(None, description="Homepage URL for the project.")
    repository: Optional[AnyUrl] = Field(None, description="Repository URL for the project.")
    documentation: Optional[AnyUrl] = Field(None, description="Documentation URL for the project.")
    license: Optional[str] = Field(None, description="License name.")
    authors: Optional[PoetryAuthors] = None
    maintainers: Optional[PoetryMaintainers] = None
    readme: Optional[Union[str, List[str]]] = None
    classifiers: Optional[List[str]] = Field(None, description="A list of trove classifiers.")
    packages: Optional[List[Package]] = Field(None, description="A list of packages to include in the final distribution.")
    include: Optional[List[Union[PoetryIncludePath, Include]]] = Field(None, description="A list of files and folders to include.")
    exclude: Optional[List[str]] = Field(None, description="A list of files and folders to exclude.")
    dependencies: Optional[Dependencies] = Field(
        None,
        description="This is a hash of package name (keys) and version constraints (values) that are required to run this package.",
    )
    dev_dependencies: Optional[Dict[constr(regex=r"^[a-zA-Z-_.0-9]+$"), PoetryDependencyAny]] = Field(
        None,
        alias="dev-dependencies",
        description="This is a hash of package name (keys) and version constraints (values) that this package requires for developing it (testing tools and such).",
    )
    extras: Optional[Dict[constr(regex=r"^[a-zA-Z-_.0-9]+$"), List[str]]] = None
    group: Optional[Dict[constr(regex=r"^[a-zA-Z-_.0-9]+$"), Group]] = Field(None, description="This represents groups of dependencies")
    build: Optional[PoetryBuildSection] = None
    scripts: Optional[
        Dict[
            constr(regex=r"^[a-zA-Z-_.0-9]+$"),
            Union[PoetryScriptLegacy, PoetryScriptTable],
        ]
    ] = Field(None, description="A hash of scripts to be installed.")
    plugins: Optional[
        Union[
            Dict[constr(regex=r"^dotenv$"), Plugins],
            Dict[
                constr(regex=r"^[a-zA-Z-_.0-9]+$"),
                Dict[constr(regex=r"^[a-zA-Z-_.0-9]+$"), str],
            ],
        ]
    ] = Field(None, description="A hash of hashes representing plugins")
    urls: Optional[Dict[constr(regex=r"^.+$"), str]] = None
    source: Optional[List[Union[Source, Source1]]] = None


class Model(BaseModel):
    __root__: PartialPoetry
