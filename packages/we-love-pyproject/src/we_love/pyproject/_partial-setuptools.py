# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2025-10-07T20:53:57+00:00

from __future__ import annotations

from typing import Dict, List, Optional, Union

from pydantic import BaseModel, Extra, Field, constr


class PackageName(BaseModel):
    __root__: str = Field(
        ...,
        description="Valid package name (importable or :pep:`561`).",
        title="Valid package name",
    )


class FileDirective(BaseModel):
    class Config:
        extra = Extra.forbid

    file: Union[str, List[str]]


class AttrDirective(BaseModel):
    class Config:
        extra = Extra.forbid

    attr: str


class Find(BaseModel):
    class Config:
        extra = Extra.forbid

    where: Optional[List[str]] = Field(
        None,
        description="Directories to be searched for packages (Unix-style relative path)",
    )
    exclude: Optional[List[str]] = Field(
        None,
        description="Exclude packages that match the values listed in this field. Can container shell-style wildcards (e.g. ``'pkg.*'``)",
    )
    include: Optional[List[str]] = Field(
        None,
        description="Restrict the found packages to just the ones listed in this field. Can container shell-style wildcards (e.g. ``'pkg.*'``)",
    )
    namespaces: Optional[bool] = Field(
        None,
        description="When ``True``, directories without a ``__init__.py`` file will also be scanned for :pep:`420`-style implicit namespaces",
    )


class FindDirective1(BaseModel):
    class Config:
        extra = Extra.forbid

    find: Optional[Find] = Field(
        None,
        description="Dynamic `package discovery <https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.",
    )


class FileDirectiveForDependencies(FileDirective):
    pass


class File(BaseModel):
    __root__: Union[str, List[str]]


class FindDirective(BaseModel):
    class Config:
        extra = Extra.forbid

    find: Optional[Find] = Field(
        None,
        description="Dynamic `package discovery <https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.",
    )


class Readme(BaseModel):
    class Config:
        extra = Extra.forbid

    content_type: Optional[str] = Field(None, alias="content-type")
    file: File


class Dynamic(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Union[AttrDirective, FileDirective]] = Field(
        None,
        description="A version dynamically loaded via either the ``attr:`` or ``file:`` directives. Please make sure the given file or attribute respects :pep:`440`. Also ensure to set ``project.dynamic`` accordingly.",
    )
    classifiers: Optional[FileDirective] = None
    description: Optional[FileDirective] = None
    entry_points: Optional[FileDirective] = Field(None, alias="entry-points")
    dependencies: Optional[FileDirectiveForDependencies] = None
    optional_dependencies: Optional[Dict[constr(regex=r".+"), FileDirectiveForDependencies]] = Field(None, alias="optional-dependencies")
    readme: Optional[Union[FileDirective, Readme]] = None


class ToolSetuptoolsTable(BaseModel):
    class Config:
        extra = Extra.forbid

    platforms: Optional[List[str]] = None
    provides: Optional[List[str]] = Field(
        None,
        description="Package and virtual package names contained within this package **(not supported by pip)**",
    )
    obsoletes: Optional[List[str]] = Field(
        None,
        description="Packages which this package renders obsolete **(not supported by pip)**",
    )
    zip_safe: Optional[bool] = Field(
        None,
        alias="zip-safe",
        description="Whether the project can be safely installed and run from a zip file. **OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and ``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).",
    )
    script_files: Optional[List[str]] = Field(
        None,
        alias="script-files",
        description="Legacy way of defining scripts (entry-points are preferred). Equivalent to the ``script`` keyword in ``setup.py`` (it was renamed to avoid confusion with entry-point based ``project.scripts`` defined in :pep:`621`). **DISCOURAGED**: generic script wrappers are tricky and may not work properly. Whenever possible, please use ``project.scripts`` instead.",
    )
    eager_resources: Optional[List[str]] = Field(
        None,
        alias="eager-resources",
        description="Resources that should be extracted together, if any of them is needed, or if any C extensions included in the project are imported. **OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and ``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).",
    )
    packages: Optional[Union[List[PackageName], FindDirective]] = Field(
        None,
        description="Packages that should be included in the distribution. It can be given either as a list of package identifiers or as a ``dict``-like structure with a single key ``find`` which corresponds to a dynamic call to ``setuptools.config.expand.find_packages`` function. The ``find`` key is associated with a nested ``dict``-like structure that can contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys, mimicking the keyword arguments of the associated function.",
    )
    package_dir: Optional[Dict[constr(regex=r"^.*$"), str]] = Field(
        None,
        alias="package-dir",
        description=":class:`dict`-like structure mapping from package names to directories where their code can be found. The empty string (as key) means that all packages are contained inside the given directory will be included in the distribution.",
    )
    package_data: Optional[Dict[constr(regex=r"^.*$"), List[str]]] = Field(
        None,
        alias="package-data",
        description="Mapping from package names to lists of glob patterns. Usually this option is not needed when using ``include-package-data = true`` For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.",
    )
    include_package_data: Optional[bool] = Field(
        None,
        alias="include-package-data",
        description="Automatically include any data files inside the package directories that are specified by ``MANIFEST.in`` For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.",
    )
    exclude_package_data: Optional[Dict[constr(regex=r"^.*$"), List[str]]] = Field(
        None,
        alias="exclude-package-data",
        description="Mapping from package names to lists of glob patterns that should be excluded For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.",
    )
    namespace_packages: Optional[List[str]] = Field(
        None,
        alias="namespace-packages",
        description="**DEPRECATED**: use implicit namespaces instead (:pep:`420`).",
    )
    py_modules: Optional[List[str]] = Field(None, alias="py-modules", description="Modules that setuptools will manipulate")
    data_files: Optional[Dict[constr(regex=r"^.*$"), List[str]]] = Field(
        None,
        alias="data-files",
        description="``dict``-like structure where each key represents a directory and the value is a list of glob patterns that should be installed in them. **DISCOURAGED**: please notice this might not work as expected with wheels. Whenever possible, consider using data files inside the package directories (or create a new namespace package that only contains data files). See `data files support <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.",
    )
    cmdclass: Optional[Dict[constr(regex=r"^.*$"), str]] = Field(
        None,
        description='Mapping of distutils-style command names to ``setuptools.Command`` subclasses which in turn should be represented by strings with a qualified class name (i.e., "dotted" form with module), e.g.::\n\n     cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n The command class should be a directly defined at the top-level of the containing module (no class nesting).',
    )
    license_files: Optional[List[str]] = Field(
        None,
        alias="license-files",
        description="**PROVISIONAL**: list of glob patterns for all license files being distributed. (likely to become standard with :pep:`639`). By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``",
    )
    dynamic: Optional[Dynamic] = Field(
        None,
        description="Instructions for loading :pep:`621`-related metadata dynamically",
    )
